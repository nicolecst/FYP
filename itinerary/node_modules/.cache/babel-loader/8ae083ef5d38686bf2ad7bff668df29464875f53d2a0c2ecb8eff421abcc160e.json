{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChangeStreamCursor = void 0;\nconst change_stream_1 = require(\"../change_stream\");\nconst constants_1 = require(\"../constants\");\nconst aggregate_1 = require(\"../operations/aggregate\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst utils_1 = require(\"../utils\");\nconst abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nclass ChangeStreamCursor extends abstract_cursor_1.AbstractCursor {\n  constructor(client, namespace, pipeline = [], options = {}) {\n    super(client, namespace, options);\n    this.pipeline = pipeline;\n    this.options = options;\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit(change_stream_1.ChangeStream.RESUME_TOKEN_CHANGED, token);\n  }\n  get resumeToken() {\n    return this._resumeToken;\n  }\n  get resumeOptions() {\n    const options = {\n      ...this.options\n    };\n    for (const key of ['resumeAfter', 'startAfter', 'startAtOperationTime']) {\n      delete options[key];\n    }\n    if (this.resumeToken != null) {\n      if (this.options.startAfter && !this.hasReceived) {\n        options.startAfter = this.resumeToken;\n      } else {\n        options.resumeAfter = this.resumeToken;\n      }\n    } else if (this.startAtOperationTime != null && (0, utils_1.maxWireVersion)(this.server) >= 7) {\n      options.startAtOperationTime = this.startAtOperationTime;\n    }\n    return options;\n  }\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.postBatchResumeToken) {\n      this.resumeToken = this.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n  _processBatch(response) {\n    const cursor = response.cursor;\n    if (cursor.postBatchResumeToken) {\n      this.postBatchResumeToken = response.cursor.postBatchResumeToken;\n      const batch = 'firstBatch' in response.cursor ? response.cursor.firstBatch : response.cursor.nextBatch;\n      if (batch.length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n  clone() {\n    return new ChangeStreamCursor(this.client, this.namespace, this.pipeline, {\n      ...this.cursorOptions\n    });\n  }\n  async _initialize(session) {\n    const aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this.pipeline, {\n      ...this.cursorOptions,\n      ...this.options,\n      session\n    });\n    const response = await (0, execute_operation_1.executeOperation)(session.client, aggregateOperation);\n    const server = aggregateOperation.server;\n    this.maxWireVersion = (0, utils_1.maxWireVersion)(server);\n    if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && this.maxWireVersion >= 7) {\n      this.startAtOperationTime = response.operationTime;\n    }\n    this._processBatch(response);\n    this.emit(constants_1.INIT, response);\n    this.emit(constants_1.RESPONSE);\n    // TODO: NODE-2882\n    return {\n      server,\n      session,\n      response\n    };\n  }\n  async getMore(batchSize) {\n    const response = await super.getMore(batchSize);\n    this.maxWireVersion = (0, utils_1.maxWireVersion)(this.server);\n    this._processBatch(response);\n    this.emit(change_stream_1.ChangeStream.MORE, response);\n    this.emit(change_stream_1.ChangeStream.RESPONSE);\n    return response;\n  }\n}\nexports.ChangeStreamCursor = ChangeStreamCursor;","map":{"version":3,"names":["change_stream_1","require","constants_1","aggregate_1","execute_operation_1","utils_1","abstract_cursor_1","ChangeStreamCursor","AbstractCursor","constructor","client","namespace","pipeline","options","_resumeToken","startAtOperationTime","startAfter","resumeToken","resumeAfter","token","emit","ChangeStream","RESUME_TOKEN_CHANGED","resumeOptions","key","hasReceived","maxWireVersion","server","cacheResumeToken","bufferedCount","postBatchResumeToken","_processBatch","response","cursor","batch","firstBatch","nextBatch","length","clone","cursorOptions","_initialize","session","aggregateOperation","AggregateOperation","executeOperation","operationTime","INIT","RESPONSE","getMore","batchSize","MORE","exports"],"sources":["../../src/cursor/change_stream_cursor.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}